4/3/2018

- "[" replace method. for multiple columns?   -- could only give values for 1 column. 


3/30/2018

- DelayedDataFrame(DDF), no-op.   -- done!
- c("LazyList") works.  -- done!
- c("DelayedDataFrame") works.   -- done!
  -- try append/remove/replace columns in DelayedDataFrame. 

- "SimpleList" requires @listData to be non-NULL in validity check. ...  
- rowData(ve) for "SNP_ARRAY" input now could return "ALLELE1/2". -- done!
- colData(ve) still returns "DataFrame" instead of "DelayedDataFrame"...?? 
  

3/21/2018

- DDF, do not carry old indexes inside. When constructing with new columns, always have NULL as index. 
- new LazyList, extends "SimpleList". 
  -- modify utility functions for LazyList and DDF@lazyIndex.   -- done.
  -- redefine setMethod("[", "LazyList")  -- done.
  -- concatenate("LazyList"), for loop updating. For the c("LazyList") method to work.  -- done!

- constructor of "DelayedDataFrame", only include NULL for original lazyIndex. 
     ordinary vector has the same index as 1-dim DelayedArray.    -- done!
- modify "extractROWS("DelayedDataFrame")". only update @lazyIndex. leave DDF untouched.  --done!
- modify show method of DDF. only print head(DDF, 5). Realization for 5 rows.  -- done!
		print("DelayedDataFrame with 10 rows and 5 columns")
		call as("DDF", "DataFrame") for realization. 
- nrow("DelayedDataFrame")  -- done!
- modify setMethod("[", "DelayedDataFrame"). -- done!

- update @nrow @rownames slots for subsetting.    -- done!
- modify "show" method for "DelayedDataFrame" with updated @nrows and @rownames. 
  -- setMethod("show", "DelayedDataFrame") removed. Could work with show("DataFrame"). -- done!
- [[]] extraction, modify to be consistent with dim(ddf). 
  -- lower level function: "getListElement("DelayedDataFrame")" defined.   -- done!
- redefine setMethod("lapply", "DelayedDataFrame") inside "show" method. 
  -- lower level function: setMethod("as.list", "DelayedDataFrame") redefined   -- done!
  -- NOTE: "as.list" is the lower level function for "lapply" and names("DDF"). 
- redine setMethod("names", "DelayedDataFrame")
  -- previously called from names(as.list(x)). Now cheaper with names(x@listData).  -- done!

- ".lazyIndex\_inuse" and reorder.   -- further touch...
  -- 1. remove any @listData that is not used in @index.   -- done!
  -- 2. remove any duplicated @listData and modify @index accordingly.  --done!
  -- 3. reorder indexes (index for 1st columns in @listData[[1]])
  -- added inside ".update\_index" (correspondingly in coercion from DF to DDF, and concatenateObject(LazyIndex)).  --done!
  -- added inside ".update\_row". So updated with "[" method.  -- done!

- lazyIndex@listData. do not distinguish (un)delayed columns, use only vector for index. -- done!
- c(LazyList), add checking validity.   -- done!
- c(ddf1, ddf2) 
  -- need to check c(LazyList), the length of each index. 
  -- c(DataFrame(ddf1), DataFrame(ddf2)) works. different lengths of @listData, is it correct? 
- cbind. -- done!
- rbind, 
  -- GDSArray returns character vector. 
  -- selectMethod("rbind", "DataFrame"). 
  -- r/cbind("GDSMatrix") inherits r/cbind("DelayedMatrix") for 2-dim DelayedArray.
  -- arbind, acbind for "DelayedArray" defined. 
	  DelayedArray:::new_SeedBinder(list(), 2L)... returns "SeedBinder" object, that could be directly used to construct a DelayedArray...
	  Redefine for "GDSArray"? need to keep the same seed! 
  -- need to define "c" method for "GDSArray" with 1-dim. --- when !rectangular. 
- Question: c(), rbind/rbind(), return a brand new DelayedDataFrame with @lazyIndex to be NULL for all?

3/20/2018

3rd iteration: 
- modify "concatenate("lazyList")" for "object=list()" argument. 
- do not propagate lazyIndex into delayed columns.   -- done. modified "update_lazyIndex".
- rbind, cbind. update @lazyIndex only, and callNextMethod(). 
- rownames. -- done!
- as("DelayedDataFrame", "DataFrame") to realize the lazyIndex into each column. 
  simply call lapply(lazyIndex, columns of DDF). 
- "[i,j,...]<-" assignment.
- "[[<-" replace, need to update lazyIndex. 

3/12/2018

- unit test  
- manual
- vignette
- assignment for DelayedDataFrame, need to update @lazyIndex slot. 
  -- "$<-" assignment, ==> "[[<-" assignment.
  -- "[[]]<-" append. -- done!
  -- "[[]]<-" replace -- need to update @lazyIndex...
  -- "[[]]<-NULL"    -- done!
  
  
3/7/2018

- Depends on GDSArray (installed locally, master 0.99.4)   -- done! 
- use GDSArray:::GDSArraySeed(). -- done!
- use GDSArray:::.get_gdsdata_...  -- done!
- modify R/... codes for updated GDSArray:AllUtilities.R functions. The input is file name in characer, not "gds.class" object.  -- done!
- VE methods: gdsfile(VE)? 
- DelayedDataFrame to include all data type.
  -- validity check.   -- done!
  -- conversion, DF->DDF   -- done!
  
- DelayedDataFrame lazyIndex to include non-delayed_ops objects.
  -- (plain atomic vector of NULL for non-delayed columns. 
  -- update_row  -- done!
  -- extractROWS(DDF)  -- check indexInUse first? update_lazyIndex. 
  -- [ subsetting.   -- 
- Coercion from DF=>DDF works. 
- update "extractROWS.DelayedDataFrame".   -- done!
- update "[DDF" when initiate(DDF, lazyIndex=new_lazyIndex). --- done!
- 
- validityCheck for DDF add length(x@has_index)==ncol(x)   -- done!
- if, else, {... add white space after. functions, new line for {. -- done!

- update documentation. -- doing...
  -- why ?DelayedDataFrame does not return any documentation?? 
  -- add example.


2/27/2018

- GDSArray into separate package? -- done!
- DelayedDataFrame into S4Vector? or separate package? 2nd iteration. keep the refClass(memory-wise save for cloning). To accomodate Delayed_ops or not. [[/"$" method.   
- unit tests. subsetting for dDF works. [, [[, 
- related manual/unit tests for each R script. 
- vignette updates. 
- DelayedDF finished, meet with Herve, Martin. 
- ??

2/22/2018
- DelayedDataFrame construction. -- done!
- GDSMatrix (2-dim GDSArray).  -- done! 
- GDSArray@index, list of named vector?
- VariantExperiment constructor?  
- import SeqArray, except for rowRanges, colData. 

2/14/2018 
- define `VariantExperiment` class, contains `SummarizedExperiment`, has gds file related, row/colData in `DelayedDataFrame` class. 
- return `VariantExperiment` from `makeSummarizedExperimentFromGDS` and `saveGDSSummarizedExperiment`. 
- when VE rowData/colData() updated with additional columns, write them into gds file with `saveGDSSummarizedExperiment`. 
 
- stat functions, export all methods?   -- done! 
- stat functions, write into rowData(se)??  -- NO!

## loadGDSSE(), if(identical(basename(gdsfile(a)), "assays.gds")) does not work.

Look into "~data" in `SeqArray`. 
```{r}
showMethods("info", where=getNamespace("SeqArray"))
## Function: info (package SeqArray)
## x="SeqVarGDSClass"
```

Friday mtg about rest of sprint: 

## 1. Remove the `.write_gdsdata_sampInCol`, do not generate the temp file. (done)
Has implemented `permute = logical` in the `GDSArraySeed` slots. And have modified `subset_seed_as_array()` function, to read the array data in gds file with corresponding indexes. e.g., For `SeqVarGDSClass` data from `SeqArray`, `permute = TRUE`, the `subset_seed_as_array` will permute the 3 indexes for variants, samples and ploidy, read from the gds file, and then permute the extracted data back to be consistent with SE structure.   

```{r, permute}
file <- system.file(package="VariantExperiment", "extdata", "CEU_Exon.gds") ##seq gds
f <- seqOpen(file)
node <- index.gdsn(f, "genotype/data")
objdesp.gdsn(node)$dim
### [1]    2   90 1348   (ploidy x sample x variants)- readex.gdsn(node, sel=list(1:2, 1:3, 1:5))
closefn.gds(f)

seqClose(f)
seed <- GDSArraySeed(file, "genotype/data")
slotNames(seed)
seed@permute
ga <- GDSArray(file)  ## or GDSArray(seed), identical
ga[1:5, 1:3, ]
aperm(as.array(ga[1:5, 1:3, ]), c(3,2,1)
seqClose(f)
```


## 2. modify `GDSArray-class.R`, by checking the file format of gds file. (done) 
	
Has implemented `.get_gdsdata_fileFormat(file)` to return `SNP_ARRAY` OR `SEQ_ARRAY` in `GDSArraySeed()`. Different functions will be used based on the file format. 

## 3. For `SEQ_ARRAY` data, genotype are in 3 dimensions, ploidy x sample x variant. (done) 

`DelayedArray` support >2 dimension data. So will just save the data in 3 dimensions, and pass to array(SE). Make sure the first 2 dimensions are always variants/SNPs and ssamples.  

## 4. makeSummarizedExperimentFromGdsfmt(file, rowDataColumns=character(), colDataColumns=character()). (done)
```{r, SE}
se <- makeSummarizedExperimentFromGdsfmt(file)
se1 <- makeSummarizedExperimentFromGdsfmt(file, rowDataColumns=c("ID", "REF", "ALT"), colDataColumns=c("family"))
se2 <- makeSummarizedExperimentFromGdsfmt(file, rowDataColumns=c("ID", "REF", "ALT", "random"), colDataColumns=c("family"))  ### warning.
assay <- assay(se2)
dim(assay)
assay[1:5, 1:3, ]
saveRDS(se, file="inst/extdata/CEU_Exon_gse.rds")
rm(se1, se2, assay, node)
```
## 5. save/loadGdsfmtSummarizedExperiment(x, dir, replace, verbose, allow.duplicate).

- modify `GDSArraySeed` and `GDSArray` to accommodate ordinary gds format data, add `SE_ARRAY` in line with `SNP_ARRAY` or `SEQ_ARRAY`. 
+ `.get_gdsdata_fileFormat` no change. But remember to add the `put.attr.gdsn(gfile$root, "FileFormat", "SE_ARRAY")` in `.write_gds_assays`.  -- done.   
+ `.get_gdsdata_arrayNodes` no change.
+ `.read_gdsdata_sampleInCol` adding `fileFormat =="SE_ARRAY"`. -- done.
+ `.get_gdsdata_dim` no change. 
+ `.get_gdsdata_dimnames` adding `fileFormat =="SE_ARRAY"` to accommodate the following change: add the `sample.id` and `row.id` in `.write_gds_assays` when creating the gds file from SE assay.  -- done.  
```
- modify `makeSummarizedExperimentFromGdsfmt`. -- done. 

```{r, saveLoad}
## rewrite the DelayedArray data to be an array.
f <- openfn.gds(file)
dat <- read.gdsn(index.gdsn(f, "genotype/data"))
dat <- aperm(dat, perm=c(3,2,1))
closefn.gds(f)
assays(se)[[1]] <- dat
asy <- assay(se, 1)
dim(asy)
class(asy)

## save/loadGdsfmtSummarizedExperiment
se1 <- saveGdsfmtSummarizedExperiment(se, replace=TRUE, verbose=TRUE)
assay(se1, 1)
se2 <- loadGdsfmtSummarizedExperiment()
assay(se2, 1)
all.equal(se1, se2)
assay(subsetByOverlaps(se1, GRanges("22:1-48958933")))
```

## 6. rewrite function names, use "GDS" instead of "Gdsfmt".  -- done!
- `save/loadGDSSummarizedExperiment()`
- `makeSummarizedExperimentFromGDS()`

## 7. todo: 
- add `INFO` from `SeqArray` data for `rowDataColumns`.   -- done!
- Remove the `allow.duplicate` from arguments.    --- done!
- add more manual context for `GDSArray-class.R`. Why doesn't load packages. -- done!

## 8. querable gds data. return the allowable values in the gds files for rowDataColumns and colDataColumns.    --- done!
coversion from SE to SeqVarGDSClass. to accommodate with SeqArray functions. 

## 9. 11/27/2017, meeting with Martin. (on-disk representation of col/rowData(SE) in `makeSummarizedExperimentFromGDS`) -- done!
```{r}
x <- 1:10
.Internal(inspect(x))
setwd("home/R/R_Devel")
grep("ALTREP")
getClass("SE")
structure(list(x=x, class="a")) ## ??
dput(node)
```
DelayedVectorClass: virtual class. extends delayedRaw, delayedIntegerList... atomic factors. ?atomic: a vector for each of the atomic modes: logical, integer, numeric, complex, character, raw...

put each of the col of colData into a DelayedVector (1-col DelayedArray), and represent them in DataFrame. 
RangedSE: rowRanges (Vector?)
SeqVarGDSClass: .S3Class. (setOldClass()) ## 

```{r DFDelayedArray}
sefile <- system.file(package="VariantExperiment", "extdata", "CEU_Exon_gse.rds")
se <- readRDS(sefile) 
coldat <- SummarizedExperiment::colData(se)
cold <- DataFrame(DelayedArray(coldat))
cold <- DataFrame(Samples = I(DelayedArray(coldat[,1, drop=FALSE])),
                  family = I(DelayedArray(coldat[,2, drop=FALSE])))
names(cold) <- c("Samples", "family")
head(cold)  ## does not work: object of type 'S4' is not subsettable
rr <- SummarizedExperiment::rowRanges(se)
rowdat <- DataFrame(data.frame(rr))
### should we retain the data type of GenomicRanges when save into DataFrame? (Rle, DNAStringSet, numeric, character...)
### how to convert DataFrame columns into DelayedArray? by retaining the data type?
### DataFrame(I(**)) To store an object of a class that does not support coercion to ‘DataFrame’, wrap it in ‘I()’. The class must still have methods for ‘length’ and ‘[’.
### What did the "I()" does here? Any other paste option except for ":"?
### show method of "DataFrame", could not use "head(DelayedMatrix)": object of type 'S4' is not subsettable. Error in `[.default`(<S4 object of class c("AsIs", "DelayedMatrix")


rowd <- DataFrame(I(DelayedArray(rowdat[1:3])),
                  strand = I(DelayedArray(rowdat[,"strand", drop=FALSE])),
                  ID = I(DelayedArray(rowdat[, "ID", drop=FALSE])),
                  REF = I(DelayedArray(rowdat[, "REF", drop=FALSE]))
                  
                  )

### herve's example
vars <- DelayedArray(matrix(round(runif(30), 2), ncol=3, dimnames=list(NULL, c("var1", "var2", "var3"))))
vars
cd <- DataFrame(vars)
colData <- DataFrame(vars=I(vars))
colData
```

## 10. mtg with martin 11/29/2017, DelayedVector exploration
```{r}
m <- matrix(1:120, 30)
da <- DelayedArray(m)
df <- DataFrame(x1 = I(da[, 1, drop=FALSE]))

## .DelayedVector_Validity <- function(object){
##     msg <- character()
##     if(ncol(object) != 1L)
##        msg <- c(msg, "'seed' must have a single dimension")
##     if(length(msg)) msg else TRUE    
## }


## implement a new method of "dim", need to rewrite DelayedArray for dim.
## need to implement length(), "[" for DelayedVector.
## reuse the DelayedArray ::: functions as much as possible.
## showMethod, removeMethod(, "class"), selectMethod(, "class")
## write a little helper function. where "dim_or_length".
```
```{r}
.DelayedVector <- setClass(
    "DelayedVector",
    contains="DelayedArray"
    ## validity = .DelayedVector_Validity
)

DelayedVector <- function(seed){
    if(is.vector(seed))
        seed <- DelayedArray(matrix(seed, length(seed)))
    else{
        seed <- DelayedArray(seed)
        stopifnot(ncol(seed) == 1L)
    }
    .DelayedVector(seed)
}

setMethod("dim", "DelayedVector", function(x){
    DelayedArray:::.get_DelayedArray_dim_before_transpose(x)[[1]]
})


## setMethod("show", "DelayedVector", function(object){
##     cat(class(object), "of", length(object), typeof(seed(object)), "s",
##         "\n", sep=" ")
##     if(length(object) > )
## })

dv <- DelayedVector(da[,1,drop=FALSE])
```

```
seqSetFilter()  ### extract the GR, set a filter, create a gds class object, run `seqSummary()`
seqAlleleFreq() ### functions accommodate with SE structure as input. 
SeqArray::Summary_geno
```
is there any clever way to do that? 
...
seqSummary() ## trial to see 
```
S3Vectors. 
```

## 5. ??GDS based SE object, coerce to VRanges. 

## 7. update the seed setter for GDSArray. create a new GDSArraySeed. (done)


```{r}
setGeneric("gdsfile", function(x) standardGeneric("gdsfile"))

setMethod("gdsfile", "GDSArraySeed", function(x) x@file)

setMethod("gdsfile", "GDSArray", function(x) gdsfile(seed(x)))
setMethod("gdsfile", "DelayedArray", function(x) gdsfile(seed(x)))

setMethod("gdsfile", "SummarizedExperiment", function(x) {
    vapply(assays(gse1), gdsfile, character(1))
})
```
import(SNPRelate)
import(VariantAnnotation)
import(gdsfmt)


## demo (12/12/2017)
$info into mcols(rowRanges(se)). 
fmt: array data into assays(se).
fmt$length: SeqArray code. invisible? length of alt alleles? multiple obs per cell of the matrix in general. 
fmt$DP, not changing it to be "depth". 
Herve: 
```
DelayedArray(matrix(list(1:2), 2,3))
DelayedMatrix object of 2 x 3 lists:
Error in seq_len(ncol(ans)) : 
  argument must be coercible to non-negative integer
In addition: Warning message:
In seq_len(ncol(ans)) : first element used of 'length.out' argument
```
GDSArray/GDSArraySeed for the row/colDataColumns/. 
```{r}
seedid <- new("GDSArraySeed", file=file, name="annotation/id", dim=1348L, dimnames=list(1:1348), permute=FALSE, first_val="rs111751804")
DataFrame(seedid=I(DelayedArray(seedid)))
### DataFrame(seedid=I(GDSArray(seedid)))
```




```{r}
### SNPGDSFileClass
### file <- system.file(package="SNPRelate", "extdata", "hapmap_geno.gds")
file <- SNPRelate::snpgdsExampleFileName()
se <- makeSummarizedExperimentFromGDS(file)
rowData(se)
SummarizedExperiment::colData(se)
metadata(se)
showAvailable(file)
se1 <- makeSummarizedExperimentFromGDS(file, rowDataColumns=c("ALLELE"), colDataColumns=c("family.id", "sex", "pop.group"))
SummarizedExperiment::rowRanges(se1)
SummarizedExperiment::colData(se1)
### SeqVarGDSClass
file <- SeqArray::seqExampleFileName(type="gds")
se <- makeSummarizedExperimentFromGDS(file)
showAvailable(file)
rowdatacols <- showAvailable(file, "rowDataColumns")$rowDataColumns
coldatacols <- showAvailable(file, "colDataColumns")$colDataColumns
infocols <- showAvailable(file, "info")$info
fmt <- showAvailable(file, "fmt")$fmt
se1 <- makeSummarizedExperimentFromGDS(
file,
rowDataColumns=rowdatacols[1:3],
colDataColumns = coldatacols[1],
info = infocols[c(3,5,7)],
fmt = fmt
)
metadata(se1)
SummarizedExperiment::rowRanges(se1)
```
```{r}
file <- SNPRelate::snpgdsExampleFileName()
gdsa <- GDSArray(file)
f <- snpgdsOpen(file)
colData <- .colData_snpgds(f)
rowRange <- .rowRanges_snpgds(f)
SummarizedExperiment(assay=gdsa, colData=colData, rowRanges= rowRange)
### Error in FUN(X[[i]], ...) : 
###   assay rownames() must be NULL or equal rowData rownames() / rowRanges
###   names()
head(rownames(gdsa))  ## integer
head(names(rowRange))  ## character
```

## send to Martin: 
gds file path
gse1.Rds

data sharing in same location (shared dir on server)


## 8. RSQLite
```{r}
library(RSQLite)
fl <- tempfile()
conn <- dbConnect(RSQLite::SQLite(), fl)
dbWriteTable(conn, "row_ranges", as.data.frame(rowRanges(se)))
dbDisconnect(conn)
db = readBin(fl, raw(), file.size(fl))
file.size(fl)
[1] 335872
length(db)
[1] 335872
head(db)
[1] 53 51 4c 69 74 65
f = openfn.gds(gds, readonly=FALSE)
add.gdsn(f, "sqlite1", db, storage="bit8", replace=TRUE)
inp <- read.gdsn(index.gdsn(f, "sqlite"), .useraw=TRUE)
writeBin(inp, "/tmp/row_ranges.sql")
conn <- dbConnect(RSQLite::RSQLite(), "/tmp/row_ranges.sql")
conn <- dbConnect(RSQLite::SQLite(), "/tmp/row_ranges.sql")
GRanges(dbReadTable(conn, "row_ranges"))
```

```{r, myNote}
file <- system.file("VariantExperiment", "extdata", "")
se <- makeSu..(file)
library(RSQLite)
args(dbWriteTable)
fl <- tempfile()
conn <- dbConnect(RSQLite::SQLite(), fl)
dbWriteTable(conn, "row_ranges", as.data.frame(rowRanges(se)))
dbDisconnect(conn)
db_readBin(fl)

db
add.gdsn(f, "sqlite", db, storage="")
writeBin()
$ sqlite3

```


## 9. useful SeqArray functions. 
```{r}
file <- system.file(package="VariantExperiment", "extdata", "CEU_Exon.gds")
file <- SeqArray::seqExampleFileName("gds")
f <- openfn.gds(file)
f$filename
a <- seqSummary(f)  ## 
names(a)
###  [1] "filename"     "version"      "reference"    "ploidy"       "num.sample"  
###  [6] "num.variant"  "allele"       "annot_qual"   "filter"       "info"        
### [11] "format"       "sample.annot"

SeqArray:::.seldim(f)
### seldim[1L] -- ploidy
### seldim[2L] -- # of selected samples
### seldim[3L] -- # of selected variants```
SeqArray:::.AddVar()

gtseq <- read.gdsn(index.gdsn(f, "genotype/data"))
als <- read.gdsn(index.gdsn(f, "allele"))
phase <- read.gdsn(index.gdsn(f, "phase/data"))
```

```{r}
library(VariantAnnotation)
vfile <- SeqArray::seqExampleFileName("vcf")
gt <- readGT(vfile)
gt[1:10, 1:5]
gtn <- readGT(vfile, nucleotides=TRUE)
gtn[1:10, 1:5]
geno <- readGeno(vfile)
```
