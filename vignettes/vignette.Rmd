---
title: "_VariantExperiment_: A Ranged Summarized Experiment container for GDS back end data"
author: "Qian Liu, Martin Morgan"
date: "Revised: 22 Nov, 2017"
abstract: >

VariantExperiment has implemented `GDSArraySeed` and `GDSArray` classes as GDS back-end for DelayedArray. The GDSArray data could stick into the SummarizedExperiment for on-disk reading, subsetting with SE common operation. 

output:
  BiocStyle::html_document:
    toc: true
Vignette: >
  %\VignetteIndexEntry{VariantExperiment}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r style, echo=FALSE, results='asis'}
BiocStyle::markdown()
```

# Introduction 

The `SummarizedExperiment` class is used to store rectangular matrices of
experimental results, which are commonly produced by sequencing and microarray
experiments.  Each object stores observations of one or more samples, along
with additional meta-data describing both the observations (features) and
samples (phenotypes).

A key aspect of the `SummarizedExperiment` class is the coordination of the
meta-data and assays when subsetting. For example, if you want to exclude a
given sample you can do for both the meta-data and assay in one operation,
which ensures the meta-data and observed data will remain in sync.  Improperly
accounting for meta and observational data has resulted in a number of
incorrect results and retractions so this is a very desirable
property.

#  Anatomy of a `SummarizedExperiment`
## Assays
## 'Row' (regions-of-interest) data
## 'Column' (sample) data
## Experiment-wide metadata

# Constructing a `SummarizedExperiment` 


# Common operations on `SummarizedExperiment`

## Subsetting

- `[` Performs two dimensional subsetting, just like subsetting a matrix
    or data frame.
```{r 2d}
# subset the first five transcripts and first three samples
se[1:10, 1:5]
```
- `$` operates on `colData()` columns, for easy sample extraction.
```{r colDataExtraction}
se[, se$family == "1328"]
```
- subsetting by `rowData()` columns.
```{r rowDataExtraction}
se[rowData(se)$REF == "T",]
```

## Getters and setters

- `rowRanges()` / (`rowData()`), `colData()`, `metadata()`
```{r getSet}
rowRanges(se)
head(colData(se))
head(rowData(se))
metadata(se)
```

## Range-based operations

- `subsetByOverlaps()`
`SummarizedExperiment` objects support all of the `findOverlaps()` methods and
associated functions.  This includes `subsetByOverlaps()`, which makes it easy
to subset a `SummarizedExperiment` object by an interval.

```{r overlap}
subsetByOverlaps(se, GRanges("22:1:48958933"))
### Subset for only rows which are in the interval 100,000 to 110,000 of
# chromosome 1
roi <- GRanges(seqnames="1", ranges=100000:1100000)
subsetByOverlaps(se, roi)
```




Friday mtg about rest of sprint: 

## 1. Remove the `.write_gdsdata_sampInCol`, do not generate the temp file. (done)
Has implemented `permute = logical` in the `GDSArraySeed` slots. And have modified `extract_array()` function, to read the array data in gds file with corresponding indexes. e.g., For `SeqVarGDSClass` data from `SeqArray`, `permute = TRUE`, the `extract_array` will permute the 3 indexes for variants, samples and ploidy, read from the gds file, and then permute the extracted data back to be consistent with SE structure.   
```{r, libraries}
library(tools)
library(S4Vectors)
library(SeqArray)
library(SNPRelate)
library(DelayedArray)
library(GenomicRanges)
library(VariantAnnotation)
```

```{r, permute}
file <- system.file(package="VariantExperiment", "extdata", "CEU_Exon.gds") ##seq gds
f <- seqOpen(file)
node <- index.gdsn(f, "genotype/data")
objdesp.gdsn(node)$dim
### [1]    2   90 1348   (ploidy x sample x variants)
d <- readex.gdsn(node, sel=list(1:2, 1:3, 1:5))
seqClose(f)
seed <- GDSArraySeed(file, "genotype/data")
slotNames(seed)
seed@permute
ga <- GDSArray(file)  ## or GDSArray(seed), identical
ga[1:5, 1:3, ]
aperm(as.array(ga[1:5, 1:3, ]), c(3,2,1))
```
## 2. modify `GDSArray-class.R`, by checking the file format of gds file. (done) 
	
Has implemented `.get_gdsdata_fileFormat(file)` to return `SNP_ARRAY` OR `SEQ_ARRAY` in `GDSArraySeed()`. Different functions will be used based on the file format. 

## 3. For `SEQ_ARRAY` data, genotype are in 3 dimensions, ploidy x sample x variant. (done) 

`DelayedArray` support >2 dimension data. So will just save the data in 3 dimensions, and pass to array(SE). Make sure the first 2 dimensions are always variants/SNPs and ssamples.  

## 4. makeSummarizedExperimentFromGdsfmt(file, rowDataColumns=character(), colDataColumns=character()). (done)
```{r, SE}
se <- makeSummarizedExperimentFromGdsfmt(file)
se1 <- makeSummarizedExperimentFromGdsfmt(file, rowDataColumns=c("ID", "REF", "ALT"), colDataColumns=c("family"))
se2 <- makeSummarizedExperimentFromGdsfmt(file, rowDataColumns=c("ID", "REF", "ALT", "random"), colDataColumns=c("family"))  ### warning.
assay <- assay(se2)
dim(assay)
assay[1:5, 1:3, ]
```
## 5. ??GDS based SE object, coerce to VRanges. 

## 7. update the seed setter for GDSArray. create a new GDSArraySeed. (done)


```{r}
setGeneric("gdsfile", function(x) standardGeneric("gdsfile"))

setMethod("gdsfile", "GDSArraySeed", function(x) x@file)

setMethod("gdsfile", "GDSArray", function(x) gdsfile(seed(x)))
setMethod("gdsfile", "DelayedArray", function(x) gdsfile(seed(x)))

setMethod("gdsfile", "SummarizedExperiment", function(x) {
    vapply(assays(gse1), gdsfile, character(1))
})
```
import(SNPRelate)
import(VariantAnnotation)
import(gdsfmt)


## demo

```{r}
file <- SNPRelate::snpgdsExampleFileName()
gdsa <- GDSArray(file)
f <- snpgdsOpen(file)
colData <- .colData_snpgds(f)
rowRange <- .rowRanges_snpgds(f)
SummarizedExperiment(assay=gdsa, colData=colData, rowRanges= rowRange)
### Error in FUN(X[[i]], ...) : 
###   assay rownames() must be NULL or equal rowData rownames() / rowRanges
###   names()
head(rownames(gdsa))  ## integer
head(names(rowRange))  ## character
```

## send to Martin: 
gds file path
gse1.Rds

data sharing in same location (shared dir on server)


## 8. RSQLite
```{r}
library(RSQLite)
fl <- tempfile()
conn <- dbConnect(RSQLite::SQLite(), fl)
dbWriteTable(conn, "row_ranges", as.data.frame(rowRanges(se)))
dbDisconnect(conn)
db = readBin(fl, raw(), file.size(fl))
file.size(fl)
[1] 335872
length(db)
[1] 335872
head(db)
[1] 53 51 4c 69 74 65
f = openfn.gds(gds, readonly=FALSE)
add.gdsn(f, "sqlite1", db, storage="bit8", replace=TRUE)
inp <- read.gdsn(index.gdsn(f, "sqlite"), .useraw=TRUE)
writeBin(inp, "/tmp/row_ranges.sql")
conn <- dbConnect(RSQLite::RSQLite(), "/tmp/row_ranges.sql")
conn <- dbConnect(RSQLite::SQLite(), "/tmp/row_ranges.sql")
GRanges(dbReadTable(conn, "row_ranges"))
```

```{r, myNote}
file <- system.file("VariantExperiment", "extdata", "")
se <- makeSu..(file)
library(RSQLite)
args(dbWriteTable)
fl <- tempfile()
conn <- dbConnect(RSQLite::SQLite(), fl)
dbWriteTable(conn, "row_ranges", as.data.frame(rowRanges(se)))
dbDisconnect(conn)
db_readBin(fl)

db
add.gdsn(f, "sqlite", db, storage="")
writeBin()
$ sqlite3

```


## 9. useful SeqArray functions. 
```{r}
file <- system.file(package="VariantExperiment", "extdata", "CEU_Exon.gds")
file <- SeqArray::seqExampleFileName("gds")
f <- openfn.gds(file)
f$filename
a <- seqSummary(f)  ## 
names(a)
###  [1] "filename"     "version"      "reference"    "ploidy"       "num.sample"  
###  [6] "num.variant"  "allele"       "annot_qual"   "filter"       "info"        
### [11] "format"       "sample.annot"

SeqArray:::.seldim(f)
### seldim[1L] -- ploidy
### seldim[2L] -- # of selected samples
### seldim[3L] -- # of selected variants```
SeqArray:::.AddVar()

gtseq <- read.gdsn(index.gdsn(f, "genotype/data"))
als <- read.gdsn(index.gdsn(f, "allele"))
phase <- read.gdsn(index.gdsn(f, "phase/data"))
```

```{r}
library(VariantAnnotation)
vfile <- SeqArray::seqExampleFileName("vcf")
gt <- readGT(vfile)
gt[1:10, 1:5]
gtn <- readGT(vfile, nucleotides=TRUE)
gtn[1:10, 1:5]
geno <- readGeno(vfile)
```
